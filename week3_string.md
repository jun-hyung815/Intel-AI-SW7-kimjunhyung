# Week 3 - 문자열 처리와 문자열 함수 구현

2025년 4월 말, 배열과 포인터에 대한 개념을 어느 정도 익힌 후 문자열 처리에 본격적으로 들어갔다. 문자열은 사실상 문자 배열이고, 포인터와 결합되면 매우 유연하게 활용되지만 그만큼 실수가 잦은 영역이었다. 특히 `char*`, `char[]`, `NULL` 문자 개념이 처음엔 혼란스러웠다.

---

## 학습 내용 정리

### 문자열의 기본 개념
- 문자열은 `char`형 배열이며, 문자열 끝에는 `\0` (NULL 문자)이 자동으로 붙는다
- 선언 방식
  - 배열 방식: `char str[10] = "hello";`
  - 포인터 방식: `char *str = "hello";`
- `scanf`, `gets`, `fgets` 등 다양한 입력 방식의 차이점 학습

### 문자열과 포인터
- 문자열 리터럴은 읽기 전용 -> 포인터로 수정하려 하면 오류 발생 가능
- `str[i]`는 `*(str + i)`와 동일하게 작동함
- 포인터 연산을 통해 문자열 순회 및 변경 가능

### 문자열 함수 구현 연습
- `strlen`: 문자열의 길이를 구함 (NULL 문자 이전까지의 길이)
- `strcpy`: 문자열 복사
- `strcmp`: 문자열 비교
- `strcat`: 문자열 이어붙이기
- 위 함수들을 표준 라이브러리 없이 직접 구현해보며 포인터 연산 연습

---

## 실습 예제

### my_strlen 함수 구현
```c
// 문자열의 길이를 계산하는 함수
int my_strlen(const char *str)
{
    int len = 0;
    while (str[len] != '\0') // 널 문자를 만날 때까지 반복
    { 
        len++; // 글자 하나마다 길이 증가
    }
    return len; // 최종 길이 반환
}
```

### my_strcpy 함수 구현
```c
// 문자열 복사 함수: src 문자열을 dest로 복사
void my_strcpy(char *dest, const char *src)
{
    while (*src != '\0') // src의 문자가 널 문자가 아닐 때까지
    { 
        *dest = *src; // 현재 문자 복사
        dest++; // 다음 위치로 이동
        src++;
    }
    *dest = '\0'; // 문자열 끝에 널 문자 추가
}
```

### my_strcmp 함수 구현
```c
// 두 문자열을 비교하는 함수: 다르면 차이값 반환, 같으면 0
int my_strcmp(const char *s1, const char *s2)
{
    while (*s1 && *s2) // 두 문자열 모두 끝나지 않았을 때
    { 
        if (*s1 != *s2) return *s1 - *s2; // 다르면 차이 반환
        s1++; // 다음 문자로 이동
        s2++;
    }
    return *s1 - *s2; // 길이가 다를 경우 널 문자 비교 결과 반환
}
```

---

## 회고
- 문자열을 단순한 문자 배열로 볼 때와 포인터로 접근할 때의 차이를 체감함
- 특히 문자열 리터럴을 포인터로 수정하려고 하면 오류가 발생한다는 점을 직접 실습하며 확인함
- `my_` 시리즈 함수를 직접 구현하면서 반복문과 포인터 연산의 기본기를 다지는 데 큰 도움이 되었음

---

## 다음 목표
- 문자열 뒤집기(`my_strrev`), 문자열 검색(`my_strstr`) 등 응용 함수 구현 도전
- 이중 포인터(`char **argv`)에 대한 개념 정리
- 포인터를 이용한 동적 메모리 할당 개념 예습
